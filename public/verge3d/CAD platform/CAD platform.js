/* __V3D_TEMPLATE__ - template-based file; delete this line to prevent this file from being updated */

'use strict';

window.addEventListener('load', e => {
    const params = v3d.AppUtils.getPageParams();
    createApp({
        containerId: 'v3d-container',
        fsButtonId: 'fullscreen-button',
        sceneURL: params.load || 'CAD platform.gltf',
        logicURL: params.logic || 'visual_logic.js',
    });
});

async function createApp({containerId, fsButtonId = null, sceneURL, logicURL = ''}) {
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }

    // some puzzles can benefit from cache
    v3d.Cache.enabled = true;

    let PL = null, PE = null;
    if (v3d.AppUtils.isXML(logicURL)) {
        const PUZZLES_DIR = '/puzzles/';
        const logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
        PL = await new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS);
        PE = v3d.PE;
    } else if (v3d.AppUtils.isJS(logicURL)) {
        PL = await new v3d.PuzzlesLoader().loadLogic(logicURL);
    }

    let initOptions = { useFullscreen: true };
    if (PL) {
        initOptions = PL.execInitPuzzles({ container: containerId }).initOptions;
    }
    sceneURL = initOptions.useCompAssets ? `${sceneURL}.xz` : sceneURL;

    const disposeFullscreen = prepareFullscreen(containerId, fsButtonId,
            initOptions.useFullscreen);
    const preloader = createPreloader(containerId, initOptions, PE);

    const app = createAppInstance(containerId, initOptions, preloader, PE);
    app.addEventListener('dispose', () => disposeFullscreen && disposeFullscreen());

    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    app.loadScene(sceneURL, () => {
        app.enableControls();
        app.run();

        if (PE) PE.updateAppInstance(app);
        if (PL) PL.init(app, initOptions);

        runCode(app, PL);
    }, null, () => {
        console.log(`Can't load the scene ${sceneURL}`);
    });

    return { app, PL };
}


function createPreloader(containerId, initOptions, PE) {
    const preloader = initOptions.useCustomPreloader
            ? createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb)
            : new v3d.SimplePreloader({ container: containerId });

    if (PE) puzzlesEditorPreparePreloader(preloader, PE);

    return preloader;
}

function createCustomPreloader(updateCb, finishCb) {
    class CustomPreloader extends v3d.Preloader {
        constructor() {
            super();
        }

        onUpdate(percentage) {
            super.onUpdate(percentage);
            if (updateCb) updateCb(percentage);
        }

        onFinish() {
            super.onFinish();
            if (finishCb) finishCb();
        }
    }

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader, PE) {
    const _onUpdate = preloader.onUpdate.bind(preloader);
    preloader.onUpdate = function(percentage) {
        _onUpdate(percentage);
        PE.loadingUpdateCb(percentage);
    }

    const _onFinish = preloader.onFinish.bind(preloader);
    preloader.onFinish = function() {
        _onFinish();
        PE.loadingFinishCb();
    }
}


function createAppInstance(containerId, initOptions, preloader, PE) {
    const ctxSettings = {};
    if (initOptions.useBkgTransp) ctxSettings.alpha = true;
    if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

    const app = new v3d.App(containerId, ctxSettings, preloader);
    if (initOptions.useBkgTransp) {
        app.clearBkgOnLoad = true;
        if (app.renderer) {
            app.renderer.setClearColor(0x000000, 0);
        }
    }

    // namespace for communicating with code generated by Puzzles
    app.ExternalInterface = {};
    prepareExternalInterface(app);
    if (PE) PE.viewportUseAppInstance(app);

    return app;
}


function prepareFullscreen(containerId, fsButtonId, useFullscreen) {
    const container = document.getElementById(containerId);
    const fsButton = document.getElementById(fsButtonId);

    if (!fsButton) {
        return null;
    }
    if (!useFullscreen) {
        if (fsButton) fsButton.style.display = 'none';
        return null;
    }

    const fsEnabled = () => document.fullscreenEnabled
            || document.webkitFullscreenEnabled
            || document.mozFullScreenEnabled
            || document.msFullscreenEnabled;
    const fsElement = () => document.fullscreenElement
            || document.webkitFullscreenElement
            || document.mozFullScreenElement
            || document.msFullscreenElement;
    const requestFs = elem => (elem.requestFullscreen
            || elem.mozRequestFullScreen
            || elem.webkitRequestFullscreen
            || elem.msRequestFullscreen).call(elem);
    const exitFs = () => (document.exitFullscreen
            || document.mozCancelFullScreen
            || document.webkitExitFullscreen
            || document.msExitFullscreen).call(document);
    const changeFs = () => {
        const elem = fsElement();
        fsButton.classList.add(elem ? 'fullscreen-close' : 'fullscreen-open');
        fsButton.classList.remove(elem ? 'fullscreen-open' : 'fullscreen-close');
    };

    function fsButtonClick(event) {
        event.stopPropagation();
        if (fsElement()) {
            exitFs();
        } else {
            requestFs(container);
        }
    }

    if (fsEnabled()) fsButton.style.display = 'inline';

    fsButton.addEventListener('click', fsButtonClick);
    document.addEventListener('webkitfullscreenchange', changeFs);
    document.addEventListener('mozfullscreenchange', changeFs);
    document.addEventListener('msfullscreenchange', changeFs);
    document.addEventListener('fullscreenchange', changeFs);

    const disposeFullscreen = () => {
        fsButton.removeEventListener('click', fsButtonClick);
        document.removeEventListener('webkitfullscreenchange', changeFs);
        document.removeEventListener('mozfullscreenchange', changeFs);
        document.removeEventListener('msfullscreenchange', changeFs);
        document.removeEventListener('fullscreenchange', changeFs);
    }

    return disposeFullscreen;
}


function prepareExternalInterface(app) {
    /**
     * Register functions in the app.ExternalInterface to call them from
     * Puzzles, e.g:
     * app.ExternalInterface.myJSFunction = function() {
     *     console.log('Hello, World!');
     * }
     */

}

function runCode(app, puzzles) {
    // Camera sync between multiple iframes (primary/detail) via window.postMessage.
    // This sends a cameraUpdate message whenever camera/target change,
    // and applies incoming setCamState with optional punchFactor.

    (function initCameraSync(){
        const cam = app.camera || (app.getCamera ? app.getCamera() : null);
        if (!cam) {
            console.warn('[Verge3D] No camera found for synchronization.');
            return;
        }
        const controls = app.controls;
        const hasTarget = !!(controls && controls.target);
        let lastState = null;
        const uid = Math.random().toString(36).slice(2);

        function getState() {
            const pos = cam.position ? [cam.position.x, cam.position.y, cam.position.z] : [0,0,0];
            const quat = cam.quaternion ? [cam.quaternion.x, cam.quaternion.y, cam.quaternion.z, cam.quaternion.w] : [0,0,0,1];
            const target = hasTarget ? [controls.target.x, controls.target.y, controls.target.z] : [0,0,0];
            const fov = cam.isPerspectiveCamera ? cam.fov : 50;
            return { pos, quat, target, fov };
        }

        function nearly(a, b, eps=1e-4) {
            return Math.abs(a - b) <= eps;
        }
        function arrNearly(a, b, eps=1e-4) {
            if (!a || !b || a.length !== b.length) return false;
            for (let i=0;i<a.length;i++) if (!nearly(a[i], b[i], eps)) return false;
            return true;
        }
        function stateEqual(a, b) {
            if (!a || !b) return false;
            return arrNearly(a.pos, b.pos) && arrNearly(a.quat, b.quat) && arrNearly(a.target, b.target) && nearly(a.fov, b.fov);
        }

        function broadcast() {
            try {
                const state = getState();
                if (!lastState || !stateEqual(state, lastState)) {
                    lastState = state;
                    if (window.parent && window.parent !== window) {
                        window.parent.postMessage({ type: 'cameraUpdate', state, sourceId: uid }, '*');
                    }
                }
            } catch (e) {
                // ignore transient read errors
            } finally {
                // use rAF to throttle to display refresh
                requestAnimationFrame(broadcast);
            }
        }

        function applyState(msg) {
            const data = msg && msg.data;
            if (!data || data.type !== 'setCamState' || !data.state) return;

            try {
                const s = data.state;
                const punchFactor = typeof data.punchFactor === 'number' ? data.punchFactor : 1.0;

                const t = new v3d.Vector3(s.target[0], s.target[1], s.target[2]);
                const p = new v3d.Vector3(s.pos[0], s.pos[1], s.pos[2]);

                // Adjust distance by punchFactor (detail view gets closer)
                const dir = p.clone().sub(t);
                if (punchFactor !== 1.0 && dir.lengthSq() > 0) {
                    dir.multiplyScalar(1 / Math.max(1e-6, punchFactor));
                }
                const newPos = t.clone().add(dir);

                if (cam.position) cam.position.copy(newPos);
                if (cam.quaternion) cam.quaternion.set(s.quat[0], s.quat[1], s.quat[2], s.quat[3]);

                if (cam.isPerspectiveCamera && typeof s.fov === 'number') {
                    cam.fov = s.fov;
                    cam.updateProjectionMatrix();
                }

                if (hasTarget) {
                    controls.target.copy(t);
                    if (typeof controls.update === 'function') controls.update();
                }

                // After applying incoming state, set lastState to the new camera state
                // so the next broadcast won't echo it back (prevents ping-pong).
                lastState = getState();
            } catch (e) {
                console.warn('[Verge3D] Failed to apply incoming camera state:', e);
            }
        }

        window.addEventListener('message', applyState);
        requestAnimationFrame(broadcast);
    })();
}
